'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _PluginSyntaxESTree2 = require('escomplex-plugin-syntax-estree/dist/PluginSyntaxESTree');

var _PluginSyntaxESTree3 = _interopRequireDefault(_PluginSyntaxESTree2);

var _ASTParser = require('typhonjs-escomplex-commons/dist/utils/ast/ASTParser');

var _ASTParser2 = _interopRequireDefault(_ASTParser);

var _TraitUtil = require('typhonjs-escomplex-commons/dist/module/traits/TraitUtil');

var _TraitUtil2 = _interopRequireDefault(_TraitUtil);

var _actualize = require('typhonjs-escomplex-commons/dist/module/traits/actualize');

var _actualize2 = _interopRequireDefault(_actualize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides an typhonjs-escomplex-module / ESComplexModule plugin which loads syntax definitions for trait resolution
 * for unique Babylon AST not found in ESTree.
 *
 * @see https://www.npmjs.com/package/typhonjs-escomplex-module
 */
var PluginSyntaxBabylon = function (_PluginSyntaxESTree) {
   _inherits(PluginSyntaxBabylon, _PluginSyntaxESTree);

   function PluginSyntaxBabylon() {
      _classCallCheck(this, PluginSyntaxBabylon);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(PluginSyntaxBabylon).apply(this, arguments));
   }

   _createClass(PluginSyntaxBabylon, [{
      key: 'BindExpression',

      // Unique Babylon AST nodes --------------------------------------------------------------------------------------

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#bindexpression
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */
      value: function BindExpression() {
         return (0, _actualize2.default)(0, 0);
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#booleanliteral
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'BooleanLiteral',
      value: function BooleanLiteral() {
         return (0, _actualize2.default)(0, 0, undefined, function (node) {
            return node.value;
         });
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#classmethod
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'ClassMethod',
      value: function ClassMethod() {
         return (0, _actualize2.default)(0, 0, function (node) {
            var operators = typeof node.computed === 'boolean' && node.computed ? [].concat(_toConsumableArray(_ASTParser2.default.parse(node.key).operators)) : [];

            operators.push(typeof node.generator === 'boolean' && node.generator ? 'function*' : 'function');

            if (node.kind && (node.kind === 'get' || node.kind === 'set')) {
               operators.push(node.kind);
            }
            if (typeof node.async === 'boolean' && node.async) {
               operators.push('async');
            }
            if (typeof node.static === 'boolean' && node.static) {
               operators.push('static');
            }
            return operators;
         }, function (node, parent) {
            return s_SAFE_COMPUTED_OPERANDS(node, parent);
         }, 'key', // Note: must skip key as the assigned name is determined above.
         function (node) {
            var name = void 0;

            if (typeof node.computed === 'boolean' && node.computed) {
               name = node.key.type === 'StringLiteral' ? _TraitUtil2.default.safeValue(node.key) : '<computed~' + _ASTParser2.default.parse(node.key).source + '>';
            } else // ClassMethod is not computed and is an `Identifier` node.
               {
                  name = _TraitUtil2.default.safeName(node.key);
               }

            return {
               type: 'method',
               name: name,
               lineStart: node.loc.start.line,
               lineEnd: node.loc.end.line,
               paramCount: node.params.length
            };
         });
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#decorator
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'Decorator',
      value: function Decorator() {
         return (0, _actualize2.default)(0, 0);
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#directive
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'Directive',
      value: function Directive() {
         return (0, _actualize2.default)(1, 0);
      }

      /**
       * Avoid conflicts between string literals and identifiers.
       *
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#directiveliteral
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'DirectiveLiteral',
      value: function DirectiveLiteral() {
         return (0, _actualize2.default)(0, 0, void 0, function (node) {
            return typeof node.value === 'string' ? '"' + node.value + '"' : node.value;
         });
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#nullliteral
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'NullLiteral',
      value: function NullLiteral() {
         return (0, _actualize2.default)(0, 0, void 0, 'null');
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#numericliteral
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'NumericLiteral',
      value: function NumericLiteral() {
         return (0, _actualize2.default)(0, 0, void 0, function (node) {
            return node.value;
         });
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#objectmethod
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'ObjectMethod',
      value: function ObjectMethod() {
         return (0, _actualize2.default)(0, 0, function (node) {
            return typeof node.kind === 'string' && (node.kind === 'get' || node.kind === 'set') ? node.kind : void 0;
         }, void 0, 'key'); // Note: must skip key as the assigned name is forwarded on to FunctionExpression.
      }

      /**
       * Note: that w/ ES6+ `:` may be omitted and the Property node defines `shorthand` to indicate this case.
       *
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#objectproperty
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'ObjectProperty',
      value: function ObjectProperty() {
         return (0, _actualize2.default)(1, 0, function (node) {
            return typeof node.shorthand === 'undefined' ? ':' : typeof node.shorthand === 'boolean' && !node.shorthand ? ':' : void 0;
         });
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#regexpliteral
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'RegExpLiteral',
      value: function RegExpLiteral() {
         return (0, _actualize2.default)(0, 0, void 0, function (node) {
            var operands = [];

            if (_typeof(node.extra) === 'object' && typeof node.extra.raw !== 'undefined') {
               operands.push(node.extra.raw);
            }

            return operands;
         });
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#restproperty
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'RestProperty',
      value: function RestProperty() {
         return (0, _actualize2.default)(0, 0, '... (rest)');
      }

      /**
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#spreadproperty
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'SpreadProperty',
      value: function SpreadProperty() {
         return (0, _actualize2.default)(0, 0, '... (spread)');
      }

      /**
       * Avoid conflicts between string literals and identifiers.
       *
       * @see https://github.com/babel/babylon/blob/master/ast/spec.md#stringliteral
       * @returns {{lloc: *, cyclomatic: *, operators: *, operands: *, ignoreKeys: *, newScope: *, dependencies: *}}
       */

   }, {
      key: 'StringLiteral',
      value: function StringLiteral() {
         return (0, _actualize2.default)(0, 0, void 0, function (node) {
            return '"' + node.value + '"';
         });
      }
   }]);

   return PluginSyntaxBabylon;
}(_PluginSyntaxESTree3.default);

/**
 * Provides a utility method that determines the operands of a method for Babylon AST nodes. If the name is a computed
 * value and not a string literal then `ASTGenerator` is invoked to determine the computed operands.
 *
 * @param {object}   node - The current AST node.
 *
 * @returns {Array<*>}
 */


exports.default = PluginSyntaxBabylon;
function s_SAFE_COMPUTED_OPERANDS(node) {
   var operands = [];

   if (typeof node.computed === 'boolean' && node.computed) {
      // The following will pick up a single literal computed value (string).
      if (node.key.type === 'StringLiteral') {
         operands.push(_TraitUtil2.default.safeValue(node.key));
      } else // Fully evaluate AST node and children for computed operands.
         {
            operands.push.apply(operands, _toConsumableArray(_ASTParser2.default.parse(node.key).operands));
         }
   } else // Parent is not computed and `parent.key` is an `Identifier` node.
      {
         operands.push(_TraitUtil2.default.safeName(node.key));
      }

   return operands;
}
module.exports = exports['default'];