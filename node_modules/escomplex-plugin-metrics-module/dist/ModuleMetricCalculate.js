"use strict";

Object.defineProperty(exports, "__esModule", {
   value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides a typhonjs-escomplex-module / ESComplexModule plugin which gathers and calculates all default metrics.
 *
 * @see https://www.npmjs.com/package/typhonjs-escomplex-commons
 * @see https://www.npmjs.com/package/typhonjs-escomplex-module
 */
var ModuleMetricCalculate = function () {
   function ModuleMetricCalculate() {
      _classCallCheck(this, ModuleMetricCalculate);
   }

   _createClass(ModuleMetricCalculate, null, [{
      key: "calculate",

      /**
       * Coordinates calculating all metrics. All module and class methods are traversed. If there are no module or class
       * methods respectively the aggregate MethodReport is used for calculations.
       *
       * @param {ModuleReport}   moduleReport - The ModuleReport being processed.
       *
       * @private
       */
      value: function calculate(moduleReport) {
         // Handle module methods.
         moduleReport.methods.forEach(function (methodReport) {
            ModuleMetricCalculate.calculateCyclomaticDensity(methodReport);
            ModuleMetricCalculate.calculateHalsteadMetrics(methodReport.halstead);
         });

         // Handle module class reports.
         moduleReport.classes.forEach(function (classReport) {
            // Process all class methods.
            classReport.methods.forEach(function (methodReport) {
               ModuleMetricCalculate.calculateCyclomaticDensity(methodReport);
               ModuleMetricCalculate.calculateHalsteadMetrics(methodReport.halstead);
            });

            ModuleMetricCalculate.calculateCyclomaticDensity(classReport.aggregateMethodReport);
            ModuleMetricCalculate.calculateHalsteadMetrics(classReport.aggregateMethodReport.halstead);
         });

         ModuleMetricCalculate.calculateCyclomaticDensity(moduleReport.aggregateMethodReport);
         ModuleMetricCalculate.calculateHalsteadMetrics(moduleReport.aggregateMethodReport.halstead);
      }

      /**
       * Calculates cyclomatic density - Proposed as a modification to cyclomatic complexity by Geoffrey K. Gill and
       * Chris F. Kemerer in 1991, this metric simply re-expresses it as a percentage of the logical lines of code. Lower
       * is better.
       *
       * @param {AggregateMethodReport}   report - An AggregateMethodReport to perform calculations on.
       *
       * @private
       */

   }, {
      key: "calculateCyclomaticDensity",
      value: function calculateCyclomaticDensity(report) {
         report.cyclomaticDensity = report.sloc.logical === 0 ? 0 : report.cyclomatic / report.sloc.logical * 100;
      }

      /**
       * Calculates Halstead metrics. In 1977, Maurice Halstead developed a set of metrics which are calculated based on
       * the number of distinct operators, the number of distinct operands, the total number of operators and the total
       * number of operands in each function. This site picks out three Halstead measures in particular: difficulty,
       * volume and effort.
       *
       * @param {HalsteadData}   halstead - A HalsteadData instance to perform calculations on.
       *
       * @see https://en.wikipedia.org/wiki/Halstead_complexity_measures
       *
       * @private
       */

   }, {
      key: "calculateHalsteadMetrics",
      value: function calculateHalsteadMetrics(halstead) {
         halstead.length = halstead.operators.total + halstead.operands.total;

         /* istanbul ignore if */
         if (halstead.length === 0) {
            halstead.reset();
         } else {
            halstead.vocabulary = halstead.operators.distinct + halstead.operands.distinct;
            halstead.difficulty = halstead.operators.distinct / 2 * (halstead.operands.distinct === 0 ? 1 : halstead.operands.total / halstead.operands.distinct);
            halstead.volume = halstead.length * (Math.log(halstead.vocabulary) / Math.log(2));
            halstead.effort = halstead.difficulty * halstead.volume;
            halstead.bugs = halstead.volume / 3000;
            halstead.time = halstead.effort / 18;
         }
      }
   }]);

   return ModuleMetricCalculate;
}();

exports.default = ModuleMetricCalculate;
module.exports = exports["default"];